// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef PROTOBUF_test_2eproto__INCLUDED
#define PROTOBUF_test_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "extensions.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_test_2eproto();
void protobuf_AssignDesc_test_2eproto();
void protobuf_ShutdownFile_test_2eproto();

class HelloA;
class HelloB;
class HelloC;
class HelloD;
class Hello;
class Award;
class DBHello;

enum EnumDef_value {
  EN_DEFAULT_VALUE = 0,
  MAX_NAME_LENGTH = 1,
  MAX_DB_SPLIT_NUM = 100,
  MAX_BUFF_NUM = 1048576
};
bool EnumDef_value_IsValid(int value);
const EnumDef_value EnumDef_value_MIN = EN_DEFAULT_VALUE;
const EnumDef_value EnumDef_value_MAX = MAX_BUFF_NUM;
const int EnumDef_value_ARRAYSIZE = EnumDef_value_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumDef_value_descriptor();
inline const ::std::string& EnumDef_value_Name(EnumDef_value value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumDef_value_descriptor(), value);
}
inline bool EnumDef_value_Parse(
    const ::std::string& name, EnumDef_value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumDef_value>(
    EnumDef_value_descriptor(), name, value);
}
// ===================================================================

class HelloA : public ::google::protobuf::Message {
 public:
  HelloA();
  virtual ~HelloA();

  HelloA(const HelloA& from);

  inline HelloA& operator=(const HelloA& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloA& default_instance();

  void Swap(HelloA* other);

  // implements Message ----------------------------------------------

  HelloA* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelloA& from);
  void MergeFrom(const HelloA& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 f1 = 1;
  inline bool has_f1() const;
  inline void clear_f1();
  static const int kF1FieldNumber = 1;
  inline ::google::protobuf::int32 f1() const;
  inline void set_f1(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:HelloA)
 private:
  inline void set_has_f1();
  inline void clear_has_f1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 f1_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static HelloA* default_instance_;
};
// -------------------------------------------------------------------

class HelloB : public ::google::protobuf::Message {
 public:
  HelloB();
  virtual ~HelloB();

  HelloB(const HelloB& from);

  inline HelloB& operator=(const HelloB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloB& default_instance();

  void Swap(HelloB* other);

  // implements Message ----------------------------------------------

  HelloB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelloB& from);
  void MergeFrom(const HelloB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 f1 = 1;
  inline bool has_f1() const;
  inline void clear_f1();
  static const int kF1FieldNumber = 1;
  inline ::google::protobuf::int32 f1() const;
  inline void set_f1(::google::protobuf::int32 value);

  // optional .HelloA a = 2;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 2;
  inline const ::HelloA& a() const;
  inline ::HelloA* mutable_a();
  inline ::HelloA* release_a();
  inline void set_allocated_a(::HelloA* a);

  // @@protoc_insertion_point(class_scope:HelloB)
 private:
  inline void set_has_f1();
  inline void clear_has_f1();
  inline void set_has_a();
  inline void clear_has_a();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::HelloA* a_;
  ::google::protobuf::int32 f1_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static HelloB* default_instance_;
};
// -------------------------------------------------------------------

class HelloC : public ::google::protobuf::Message {
 public:
  HelloC();
  virtual ~HelloC();

  HelloC(const HelloC& from);

  inline HelloC& operator=(const HelloC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloC& default_instance();

  void Swap(HelloC* other);

  // implements Message ----------------------------------------------

  HelloC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelloC& from);
  void MergeFrom(const HelloC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 f1 = 1;
  inline bool has_f1() const;
  inline void clear_f1();
  static const int kF1FieldNumber = 1;
  inline ::google::protobuf::int32 f1() const;
  inline void set_f1(::google::protobuf::int32 value);

  // optional .HelloB b = 2;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 2;
  inline const ::HelloB& b() const;
  inline ::HelloB* mutable_b();
  inline ::HelloB* release_b();
  inline void set_allocated_b(::HelloB* b);

  // @@protoc_insertion_point(class_scope:HelloC)
 private:
  inline void set_has_f1();
  inline void clear_has_f1();
  inline void set_has_b();
  inline void clear_has_b();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::HelloB* b_;
  ::google::protobuf::int32 f1_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static HelloC* default_instance_;
};
// -------------------------------------------------------------------

class HelloD : public ::google::protobuf::Message {
 public:
  HelloD();
  virtual ~HelloD();

  HelloD(const HelloD& from);

  inline HelloD& operator=(const HelloD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloD& default_instance();

  void Swap(HelloD* other);

  // implements Message ----------------------------------------------

  HelloD* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelloD& from);
  void MergeFrom(const HelloD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 f1 = 1;
  inline bool has_f1() const;
  inline void clear_f1();
  static const int kF1FieldNumber = 1;
  inline ::google::protobuf::int32 f1() const;
  inline void set_f1(::google::protobuf::int32 value);

  // optional .HelloB b = 2;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 2;
  inline const ::HelloB& b() const;
  inline ::HelloB* mutable_b();
  inline ::HelloB* release_b();
  inline void set_allocated_b(::HelloB* b);

  // optional .HelloC c = 3;
  inline bool has_c() const;
  inline void clear_c();
  static const int kCFieldNumber = 3;
  inline const ::HelloC& c() const;
  inline ::HelloC* mutable_c();
  inline ::HelloC* release_c();
  inline void set_allocated_c(::HelloC* c);

  // repeated bytes d = 4;
  inline int d_size() const;
  inline void clear_d();
  static const int kDFieldNumber = 4;
  inline const ::std::string& d(int index) const;
  inline ::std::string* mutable_d(int index);
  inline void set_d(int index, const ::std::string& value);
  inline void set_d(int index, const char* value);
  inline void set_d(int index, const void* value, size_t size);
  inline ::std::string* add_d();
  inline void add_d(const ::std::string& value);
  inline void add_d(const char* value);
  inline void add_d(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& d() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_d();

  // @@protoc_insertion_point(class_scope:HelloD)
 private:
  inline void set_has_f1();
  inline void clear_has_f1();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_c();
  inline void clear_has_c();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::HelloB* b_;
  ::HelloC* c_;
  ::google::protobuf::RepeatedPtrField< ::std::string> d_;
  ::google::protobuf::int32 f1_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static HelloD* default_instance_;
};
// -------------------------------------------------------------------

class Hello : public ::google::protobuf::Message {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();

  void Swap(Hello* other);

  // implements Message ----------------------------------------------

  Hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated string myworld = 2;
  inline int myworld_size() const;
  inline void clear_myworld();
  static const int kMyworldFieldNumber = 2;
  inline const ::std::string& myworld(int index) const;
  inline ::std::string* mutable_myworld(int index);
  inline void set_myworld(int index, const ::std::string& value);
  inline void set_myworld(int index, const char* value);
  inline void set_myworld(int index, const char* value, size_t size);
  inline ::std::string* add_myworld();
  inline void add_myworld(const ::std::string& value);
  inline void add_myworld(const char* value);
  inline void add_myworld(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& myworld() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_myworld();

  // optional .HelloD d = 4;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 4;
  inline const ::HelloD& d() const;
  inline ::HelloD* mutable_d();
  inline ::HelloD* release_d();
  inline void set_allocated_d(::HelloD* d);

  // optional .EnumDef_value ev = 10;
  inline bool has_ev() const;
  inline void clear_ev();
  static const int kEvFieldNumber = 10;
  inline ::EnumDef_value ev() const;
  inline void set_ev(::EnumDef_value value);

  // @@protoc_insertion_point(class_scope:Hello)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_d();
  inline void clear_has_d();
  inline void set_has_ev();
  inline void clear_has_ev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> myworld_;
  ::google::protobuf::int32 id_;
  int ev_;
  ::HelloD* d_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class Award : public ::google::protobuf::Message {
 public:
  Award();
  virtual ~Award();

  Award(const Award& from);

  inline Award& operator=(const Award& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Award& default_instance();

  void Swap(Award* other);

  // implements Message ----------------------------------------------

  Award* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Award& from);
  void MergeFrom(const Award& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 param = 3;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Award)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 param_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static Award* default_instance_;
};
// -------------------------------------------------------------------

class DBHello : public ::google::protobuf::Message {
 public:
  DBHello();
  virtual ~DBHello();

  DBHello(const DBHello& from);

  inline DBHello& operator=(const DBHello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBHello& default_instance();

  void Swap(DBHello* other);

  // implements Message ----------------------------------------------

  DBHello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBHello& from);
  void MergeFrom(const DBHello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 pk1 = 1;
  inline bool has_pk1() const;
  inline void clear_pk1();
  static const int kPk1FieldNumber = 1;
  inline ::google::protobuf::uint64 pk1() const;
  inline void set_pk1(::google::protobuf::uint64 value);

  // required string pk2 = 2;
  inline bool has_pk2() const;
  inline void clear_pk2();
  static const int kPk2FieldNumber = 2;
  inline const ::std::string& pk2() const;
  inline void set_pk2(const ::std::string& value);
  inline void set_pk2(const char* value);
  inline void set_pk2(const char* value, size_t size);
  inline ::std::string* mutable_pk2();
  inline ::std::string* release_pk2();
  inline void set_allocated_pk2(::std::string* pk2);

  // optional uint32 f1 = 3;
  inline bool has_f1() const;
  inline void clear_f1();
  static const int kF1FieldNumber = 3;
  inline ::google::protobuf::uint32 f1() const;
  inline void set_f1(::google::protobuf::uint32 value);

  // optional string f2 = 4;
  inline bool has_f2() const;
  inline void clear_f2();
  static const int kF2FieldNumber = 4;
  inline const ::std::string& f2() const;
  inline void set_f2(const ::std::string& value);
  inline void set_f2(const char* value);
  inline void set_f2(const char* value, size_t size);
  inline ::std::string* mutable_f2();
  inline ::std::string* release_f2();
  inline void set_allocated_f2(::std::string* f2);

  // optional .Hello hello = 5;
  inline bool has_hello() const;
  inline void clear_hello();
  static const int kHelloFieldNumber = 5;
  inline const ::Hello& hello() const;
  inline ::Hello* mutable_hello();
  inline ::Hello* release_hello();
  inline void set_allocated_hello(::Hello* hello);

  // optional bool b4 = 6;
  inline bool has_b4() const;
  inline void clear_b4();
  static const int kB4FieldNumber = 6;
  inline bool b4() const;
  inline void set_b4(bool value);

  // optional bytes bytesmsg = 7;
  inline bool has_bytesmsg() const;
  inline void clear_bytesmsg();
  static const int kBytesmsgFieldNumber = 7;
  inline const ::std::string& bytesmsg() const;
  inline void set_bytesmsg(const ::std::string& value);
  inline void set_bytesmsg(const char* value);
  inline void set_bytesmsg(const void* value, size_t size);
  inline ::std::string* mutable_bytesmsg();
  inline ::std::string* release_bytesmsg();
  inline void set_allocated_bytesmsg(::std::string* bytesmsg);

  // repeated uint32 repeat_test = 8;
  inline int repeat_test_size() const;
  inline void clear_repeat_test();
  static const int kRepeatTestFieldNumber = 8;
  inline ::google::protobuf::uint32 repeat_test(int index) const;
  inline void set_repeat_test(int index, ::google::protobuf::uint32 value);
  inline void add_repeat_test(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      repeat_test() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_repeat_test();

  // repeated .Award repeat_msg = 9;
  inline int repeat_msg_size() const;
  inline void clear_repeat_msg();
  static const int kRepeatMsgFieldNumber = 9;
  inline const ::Award& repeat_msg(int index) const;
  inline ::Award* mutable_repeat_msg(int index);
  inline ::Award* add_repeat_msg();
  inline const ::google::protobuf::RepeatedPtrField< ::Award >&
      repeat_msg() const;
  inline ::google::protobuf::RepeatedPtrField< ::Award >*
      mutable_repeat_msg();

  // optional .EnumDef_value ev = 10;
  inline bool has_ev() const;
  inline void clear_ev();
  static const int kEvFieldNumber = 10;
  inline ::EnumDef_value ev() const;
  inline void set_ev(::EnumDef_value value);

  // @@protoc_insertion_point(class_scope:DBHello)
 private:
  inline void set_has_pk1();
  inline void clear_has_pk1();
  inline void set_has_pk2();
  inline void clear_has_pk2();
  inline void set_has_f1();
  inline void clear_has_f1();
  inline void set_has_f2();
  inline void clear_has_f2();
  inline void set_has_hello();
  inline void clear_has_hello();
  inline void set_has_b4();
  inline void clear_has_b4();
  inline void set_has_bytesmsg();
  inline void clear_has_bytesmsg();
  inline void set_has_ev();
  inline void clear_has_ev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 pk1_;
  ::std::string* pk2_;
  ::std::string* f2_;
  ::google::protobuf::uint32 f1_;
  bool b4_;
  ::Hello* hello_;
  ::std::string* bytesmsg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > repeat_test_;
  ::google::protobuf::RepeatedPtrField< ::Award > repeat_msg_;
  int ev_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static DBHello* default_instance_;
};
// ===================================================================


// ===================================================================

// HelloA

// optional int32 f1 = 1;
inline bool HelloA::has_f1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloA::set_has_f1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloA::clear_has_f1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloA::clear_f1() {
  f1_ = 0;
  clear_has_f1();
}
inline ::google::protobuf::int32 HelloA::f1() const {
  // @@protoc_insertion_point(field_get:HelloA.f1)
  return f1_;
}
inline void HelloA::set_f1(::google::protobuf::int32 value) {
  set_has_f1();
  f1_ = value;
  // @@protoc_insertion_point(field_set:HelloA.f1)
}

// -------------------------------------------------------------------

// HelloB

// optional int32 f1 = 1;
inline bool HelloB::has_f1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloB::set_has_f1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloB::clear_has_f1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloB::clear_f1() {
  f1_ = 0;
  clear_has_f1();
}
inline ::google::protobuf::int32 HelloB::f1() const {
  // @@protoc_insertion_point(field_get:HelloB.f1)
  return f1_;
}
inline void HelloB::set_f1(::google::protobuf::int32 value) {
  set_has_f1();
  f1_ = value;
  // @@protoc_insertion_point(field_set:HelloB.f1)
}

// optional .HelloA a = 2;
inline bool HelloB::has_a() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelloB::set_has_a() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelloB::clear_has_a() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelloB::clear_a() {
  if (a_ != NULL) a_->::HelloA::Clear();
  clear_has_a();
}
inline const ::HelloA& HelloB::a() const {
  // @@protoc_insertion_point(field_get:HelloB.a)
  return a_ != NULL ? *a_ : *default_instance_->a_;
}
inline ::HelloA* HelloB::mutable_a() {
  set_has_a();
  if (a_ == NULL) a_ = new ::HelloA;
  // @@protoc_insertion_point(field_mutable:HelloB.a)
  return a_;
}
inline ::HelloA* HelloB::release_a() {
  clear_has_a();
  ::HelloA* temp = a_;
  a_ = NULL;
  return temp;
}
inline void HelloB::set_allocated_a(::HelloA* a) {
  delete a_;
  a_ = a;
  if (a) {
    set_has_a();
  } else {
    clear_has_a();
  }
  // @@protoc_insertion_point(field_set_allocated:HelloB.a)
}

// -------------------------------------------------------------------

// HelloC

// optional int32 f1 = 1;
inline bool HelloC::has_f1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloC::set_has_f1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloC::clear_has_f1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloC::clear_f1() {
  f1_ = 0;
  clear_has_f1();
}
inline ::google::protobuf::int32 HelloC::f1() const {
  // @@protoc_insertion_point(field_get:HelloC.f1)
  return f1_;
}
inline void HelloC::set_f1(::google::protobuf::int32 value) {
  set_has_f1();
  f1_ = value;
  // @@protoc_insertion_point(field_set:HelloC.f1)
}

// optional .HelloB b = 2;
inline bool HelloC::has_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelloC::set_has_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelloC::clear_has_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelloC::clear_b() {
  if (b_ != NULL) b_->::HelloB::Clear();
  clear_has_b();
}
inline const ::HelloB& HelloC::b() const {
  // @@protoc_insertion_point(field_get:HelloC.b)
  return b_ != NULL ? *b_ : *default_instance_->b_;
}
inline ::HelloB* HelloC::mutable_b() {
  set_has_b();
  if (b_ == NULL) b_ = new ::HelloB;
  // @@protoc_insertion_point(field_mutable:HelloC.b)
  return b_;
}
inline ::HelloB* HelloC::release_b() {
  clear_has_b();
  ::HelloB* temp = b_;
  b_ = NULL;
  return temp;
}
inline void HelloC::set_allocated_b(::HelloB* b) {
  delete b_;
  b_ = b;
  if (b) {
    set_has_b();
  } else {
    clear_has_b();
  }
  // @@protoc_insertion_point(field_set_allocated:HelloC.b)
}

// -------------------------------------------------------------------

// HelloD

// optional int32 f1 = 1;
inline bool HelloD::has_f1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloD::set_has_f1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloD::clear_has_f1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloD::clear_f1() {
  f1_ = 0;
  clear_has_f1();
}
inline ::google::protobuf::int32 HelloD::f1() const {
  // @@protoc_insertion_point(field_get:HelloD.f1)
  return f1_;
}
inline void HelloD::set_f1(::google::protobuf::int32 value) {
  set_has_f1();
  f1_ = value;
  // @@protoc_insertion_point(field_set:HelloD.f1)
}

// optional .HelloB b = 2;
inline bool HelloD::has_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelloD::set_has_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelloD::clear_has_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelloD::clear_b() {
  if (b_ != NULL) b_->::HelloB::Clear();
  clear_has_b();
}
inline const ::HelloB& HelloD::b() const {
  // @@protoc_insertion_point(field_get:HelloD.b)
  return b_ != NULL ? *b_ : *default_instance_->b_;
}
inline ::HelloB* HelloD::mutable_b() {
  set_has_b();
  if (b_ == NULL) b_ = new ::HelloB;
  // @@protoc_insertion_point(field_mutable:HelloD.b)
  return b_;
}
inline ::HelloB* HelloD::release_b() {
  clear_has_b();
  ::HelloB* temp = b_;
  b_ = NULL;
  return temp;
}
inline void HelloD::set_allocated_b(::HelloB* b) {
  delete b_;
  b_ = b;
  if (b) {
    set_has_b();
  } else {
    clear_has_b();
  }
  // @@protoc_insertion_point(field_set_allocated:HelloD.b)
}

// optional .HelloC c = 3;
inline bool HelloD::has_c() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HelloD::set_has_c() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HelloD::clear_has_c() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HelloD::clear_c() {
  if (c_ != NULL) c_->::HelloC::Clear();
  clear_has_c();
}
inline const ::HelloC& HelloD::c() const {
  // @@protoc_insertion_point(field_get:HelloD.c)
  return c_ != NULL ? *c_ : *default_instance_->c_;
}
inline ::HelloC* HelloD::mutable_c() {
  set_has_c();
  if (c_ == NULL) c_ = new ::HelloC;
  // @@protoc_insertion_point(field_mutable:HelloD.c)
  return c_;
}
inline ::HelloC* HelloD::release_c() {
  clear_has_c();
  ::HelloC* temp = c_;
  c_ = NULL;
  return temp;
}
inline void HelloD::set_allocated_c(::HelloC* c) {
  delete c_;
  c_ = c;
  if (c) {
    set_has_c();
  } else {
    clear_has_c();
  }
  // @@protoc_insertion_point(field_set_allocated:HelloD.c)
}

// repeated bytes d = 4;
inline int HelloD::d_size() const {
  return d_.size();
}
inline void HelloD::clear_d() {
  d_.Clear();
}
inline const ::std::string& HelloD::d(int index) const {
  // @@protoc_insertion_point(field_get:HelloD.d)
  return d_.Get(index);
}
inline ::std::string* HelloD::mutable_d(int index) {
  // @@protoc_insertion_point(field_mutable:HelloD.d)
  return d_.Mutable(index);
}
inline void HelloD::set_d(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:HelloD.d)
  d_.Mutable(index)->assign(value);
}
inline void HelloD::set_d(int index, const char* value) {
  d_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HelloD.d)
}
inline void HelloD::set_d(int index, const void* value, size_t size) {
  d_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HelloD.d)
}
inline ::std::string* HelloD::add_d() {
  return d_.Add();
}
inline void HelloD::add_d(const ::std::string& value) {
  d_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HelloD.d)
}
inline void HelloD::add_d(const char* value) {
  d_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HelloD.d)
}
inline void HelloD::add_d(const void* value, size_t size) {
  d_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HelloD.d)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HelloD::d() const {
  // @@protoc_insertion_point(field_list:HelloD.d)
  return d_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HelloD::mutable_d() {
  // @@protoc_insertion_point(field_mutable_list:HelloD.d)
  return &d_;
}

// -------------------------------------------------------------------

// Hello

// optional int32 id = 1;
inline bool Hello::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hello::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hello::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hello::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Hello::id() const {
  // @@protoc_insertion_point(field_get:Hello.id)
  return id_;
}
inline void Hello::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Hello.id)
}

// repeated string myworld = 2;
inline int Hello::myworld_size() const {
  return myworld_.size();
}
inline void Hello::clear_myworld() {
  myworld_.Clear();
}
inline const ::std::string& Hello::myworld(int index) const {
  // @@protoc_insertion_point(field_get:Hello.myworld)
  return myworld_.Get(index);
}
inline ::std::string* Hello::mutable_myworld(int index) {
  // @@protoc_insertion_point(field_mutable:Hello.myworld)
  return myworld_.Mutable(index);
}
inline void Hello::set_myworld(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Hello.myworld)
  myworld_.Mutable(index)->assign(value);
}
inline void Hello::set_myworld(int index, const char* value) {
  myworld_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Hello.myworld)
}
inline void Hello::set_myworld(int index, const char* value, size_t size) {
  myworld_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Hello.myworld)
}
inline ::std::string* Hello::add_myworld() {
  return myworld_.Add();
}
inline void Hello::add_myworld(const ::std::string& value) {
  myworld_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Hello.myworld)
}
inline void Hello::add_myworld(const char* value) {
  myworld_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Hello.myworld)
}
inline void Hello::add_myworld(const char* value, size_t size) {
  myworld_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Hello.myworld)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Hello::myworld() const {
  // @@protoc_insertion_point(field_list:Hello.myworld)
  return myworld_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Hello::mutable_myworld() {
  // @@protoc_insertion_point(field_mutable_list:Hello.myworld)
  return &myworld_;
}

// optional .HelloD d = 4;
inline bool Hello::has_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hello::set_has_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hello::clear_has_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hello::clear_d() {
  if (d_ != NULL) d_->::HelloD::Clear();
  clear_has_d();
}
inline const ::HelloD& Hello::d() const {
  // @@protoc_insertion_point(field_get:Hello.d)
  return d_ != NULL ? *d_ : *default_instance_->d_;
}
inline ::HelloD* Hello::mutable_d() {
  set_has_d();
  if (d_ == NULL) d_ = new ::HelloD;
  // @@protoc_insertion_point(field_mutable:Hello.d)
  return d_;
}
inline ::HelloD* Hello::release_d() {
  clear_has_d();
  ::HelloD* temp = d_;
  d_ = NULL;
  return temp;
}
inline void Hello::set_allocated_d(::HelloD* d) {
  delete d_;
  d_ = d;
  if (d) {
    set_has_d();
  } else {
    clear_has_d();
  }
  // @@protoc_insertion_point(field_set_allocated:Hello.d)
}

// optional .EnumDef_value ev = 10;
inline bool Hello::has_ev() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hello::set_has_ev() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hello::clear_has_ev() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hello::clear_ev() {
  ev_ = 0;
  clear_has_ev();
}
inline ::EnumDef_value Hello::ev() const {
  // @@protoc_insertion_point(field_get:Hello.ev)
  return static_cast< ::EnumDef_value >(ev_);
}
inline void Hello::set_ev(::EnumDef_value value) {
  assert(::EnumDef_value_IsValid(value));
  set_has_ev();
  ev_ = value;
  // @@protoc_insertion_point(field_set:Hello.ev)
}

// -------------------------------------------------------------------

// Award

// optional uint32 id = 1;
inline bool Award::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Award::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Award::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Award::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Award::id() const {
  // @@protoc_insertion_point(field_get:Award.id)
  return id_;
}
inline void Award::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Award.id)
}

// optional uint32 num = 2;
inline bool Award::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Award::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Award::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Award::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 Award::num() const {
  // @@protoc_insertion_point(field_get:Award.num)
  return num_;
}
inline void Award::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:Award.num)
}

// optional uint32 param = 3;
inline bool Award::has_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Award::set_has_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Award::clear_has_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Award::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 Award::param() const {
  // @@protoc_insertion_point(field_get:Award.param)
  return param_;
}
inline void Award::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Award.param)
}

// -------------------------------------------------------------------

// DBHello

// required uint64 pk1 = 1;
inline bool DBHello::has_pk1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBHello::set_has_pk1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBHello::clear_has_pk1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBHello::clear_pk1() {
  pk1_ = GOOGLE_ULONGLONG(0);
  clear_has_pk1();
}
inline ::google::protobuf::uint64 DBHello::pk1() const {
  // @@protoc_insertion_point(field_get:DBHello.pk1)
  return pk1_;
}
inline void DBHello::set_pk1(::google::protobuf::uint64 value) {
  set_has_pk1();
  pk1_ = value;
  // @@protoc_insertion_point(field_set:DBHello.pk1)
}

// required string pk2 = 2;
inline bool DBHello::has_pk2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBHello::set_has_pk2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBHello::clear_has_pk2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBHello::clear_pk2() {
  if (pk2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pk2_->clear();
  }
  clear_has_pk2();
}
inline const ::std::string& DBHello::pk2() const {
  // @@protoc_insertion_point(field_get:DBHello.pk2)
  return *pk2_;
}
inline void DBHello::set_pk2(const ::std::string& value) {
  set_has_pk2();
  if (pk2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pk2_ = new ::std::string;
  }
  pk2_->assign(value);
  // @@protoc_insertion_point(field_set:DBHello.pk2)
}
inline void DBHello::set_pk2(const char* value) {
  set_has_pk2();
  if (pk2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pk2_ = new ::std::string;
  }
  pk2_->assign(value);
  // @@protoc_insertion_point(field_set_char:DBHello.pk2)
}
inline void DBHello::set_pk2(const char* value, size_t size) {
  set_has_pk2();
  if (pk2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pk2_ = new ::std::string;
  }
  pk2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DBHello.pk2)
}
inline ::std::string* DBHello::mutable_pk2() {
  set_has_pk2();
  if (pk2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pk2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DBHello.pk2)
  return pk2_;
}
inline ::std::string* DBHello::release_pk2() {
  clear_has_pk2();
  if (pk2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pk2_;
    pk2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DBHello::set_allocated_pk2(::std::string* pk2) {
  if (pk2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pk2_;
  }
  if (pk2) {
    set_has_pk2();
    pk2_ = pk2;
  } else {
    clear_has_pk2();
    pk2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DBHello.pk2)
}

// optional uint32 f1 = 3;
inline bool DBHello::has_f1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBHello::set_has_f1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBHello::clear_has_f1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBHello::clear_f1() {
  f1_ = 0u;
  clear_has_f1();
}
inline ::google::protobuf::uint32 DBHello::f1() const {
  // @@protoc_insertion_point(field_get:DBHello.f1)
  return f1_;
}
inline void DBHello::set_f1(::google::protobuf::uint32 value) {
  set_has_f1();
  f1_ = value;
  // @@protoc_insertion_point(field_set:DBHello.f1)
}

// optional string f2 = 4;
inline bool DBHello::has_f2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBHello::set_has_f2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBHello::clear_has_f2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBHello::clear_f2() {
  if (f2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    f2_->clear();
  }
  clear_has_f2();
}
inline const ::std::string& DBHello::f2() const {
  // @@protoc_insertion_point(field_get:DBHello.f2)
  return *f2_;
}
inline void DBHello::set_f2(const ::std::string& value) {
  set_has_f2();
  if (f2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    f2_ = new ::std::string;
  }
  f2_->assign(value);
  // @@protoc_insertion_point(field_set:DBHello.f2)
}
inline void DBHello::set_f2(const char* value) {
  set_has_f2();
  if (f2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    f2_ = new ::std::string;
  }
  f2_->assign(value);
  // @@protoc_insertion_point(field_set_char:DBHello.f2)
}
inline void DBHello::set_f2(const char* value, size_t size) {
  set_has_f2();
  if (f2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    f2_ = new ::std::string;
  }
  f2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DBHello.f2)
}
inline ::std::string* DBHello::mutable_f2() {
  set_has_f2();
  if (f2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    f2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DBHello.f2)
  return f2_;
}
inline ::std::string* DBHello::release_f2() {
  clear_has_f2();
  if (f2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = f2_;
    f2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DBHello::set_allocated_f2(::std::string* f2) {
  if (f2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete f2_;
  }
  if (f2) {
    set_has_f2();
    f2_ = f2;
  } else {
    clear_has_f2();
    f2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DBHello.f2)
}

// optional .Hello hello = 5;
inline bool DBHello::has_hello() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DBHello::set_has_hello() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DBHello::clear_has_hello() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DBHello::clear_hello() {
  if (hello_ != NULL) hello_->::Hello::Clear();
  clear_has_hello();
}
inline const ::Hello& DBHello::hello() const {
  // @@protoc_insertion_point(field_get:DBHello.hello)
  return hello_ != NULL ? *hello_ : *default_instance_->hello_;
}
inline ::Hello* DBHello::mutable_hello() {
  set_has_hello();
  if (hello_ == NULL) hello_ = new ::Hello;
  // @@protoc_insertion_point(field_mutable:DBHello.hello)
  return hello_;
}
inline ::Hello* DBHello::release_hello() {
  clear_has_hello();
  ::Hello* temp = hello_;
  hello_ = NULL;
  return temp;
}
inline void DBHello::set_allocated_hello(::Hello* hello) {
  delete hello_;
  hello_ = hello;
  if (hello) {
    set_has_hello();
  } else {
    clear_has_hello();
  }
  // @@protoc_insertion_point(field_set_allocated:DBHello.hello)
}

// optional bool b4 = 6;
inline bool DBHello::has_b4() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DBHello::set_has_b4() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DBHello::clear_has_b4() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DBHello::clear_b4() {
  b4_ = false;
  clear_has_b4();
}
inline bool DBHello::b4() const {
  // @@protoc_insertion_point(field_get:DBHello.b4)
  return b4_;
}
inline void DBHello::set_b4(bool value) {
  set_has_b4();
  b4_ = value;
  // @@protoc_insertion_point(field_set:DBHello.b4)
}

// optional bytes bytesmsg = 7;
inline bool DBHello::has_bytesmsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DBHello::set_has_bytesmsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DBHello::clear_has_bytesmsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DBHello::clear_bytesmsg() {
  if (bytesmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bytesmsg_->clear();
  }
  clear_has_bytesmsg();
}
inline const ::std::string& DBHello::bytesmsg() const {
  // @@protoc_insertion_point(field_get:DBHello.bytesmsg)
  return *bytesmsg_;
}
inline void DBHello::set_bytesmsg(const ::std::string& value) {
  set_has_bytesmsg();
  if (bytesmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bytesmsg_ = new ::std::string;
  }
  bytesmsg_->assign(value);
  // @@protoc_insertion_point(field_set:DBHello.bytesmsg)
}
inline void DBHello::set_bytesmsg(const char* value) {
  set_has_bytesmsg();
  if (bytesmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bytesmsg_ = new ::std::string;
  }
  bytesmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:DBHello.bytesmsg)
}
inline void DBHello::set_bytesmsg(const void* value, size_t size) {
  set_has_bytesmsg();
  if (bytesmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bytesmsg_ = new ::std::string;
  }
  bytesmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DBHello.bytesmsg)
}
inline ::std::string* DBHello::mutable_bytesmsg() {
  set_has_bytesmsg();
  if (bytesmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bytesmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DBHello.bytesmsg)
  return bytesmsg_;
}
inline ::std::string* DBHello::release_bytesmsg() {
  clear_has_bytesmsg();
  if (bytesmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bytesmsg_;
    bytesmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DBHello::set_allocated_bytesmsg(::std::string* bytesmsg) {
  if (bytesmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bytesmsg_;
  }
  if (bytesmsg) {
    set_has_bytesmsg();
    bytesmsg_ = bytesmsg;
  } else {
    clear_has_bytesmsg();
    bytesmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DBHello.bytesmsg)
}

// repeated uint32 repeat_test = 8;
inline int DBHello::repeat_test_size() const {
  return repeat_test_.size();
}
inline void DBHello::clear_repeat_test() {
  repeat_test_.Clear();
}
inline ::google::protobuf::uint32 DBHello::repeat_test(int index) const {
  // @@protoc_insertion_point(field_get:DBHello.repeat_test)
  return repeat_test_.Get(index);
}
inline void DBHello::set_repeat_test(int index, ::google::protobuf::uint32 value) {
  repeat_test_.Set(index, value);
  // @@protoc_insertion_point(field_set:DBHello.repeat_test)
}
inline void DBHello::add_repeat_test(::google::protobuf::uint32 value) {
  repeat_test_.Add(value);
  // @@protoc_insertion_point(field_add:DBHello.repeat_test)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DBHello::repeat_test() const {
  // @@protoc_insertion_point(field_list:DBHello.repeat_test)
  return repeat_test_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DBHello::mutable_repeat_test() {
  // @@protoc_insertion_point(field_mutable_list:DBHello.repeat_test)
  return &repeat_test_;
}

// repeated .Award repeat_msg = 9;
inline int DBHello::repeat_msg_size() const {
  return repeat_msg_.size();
}
inline void DBHello::clear_repeat_msg() {
  repeat_msg_.Clear();
}
inline const ::Award& DBHello::repeat_msg(int index) const {
  // @@protoc_insertion_point(field_get:DBHello.repeat_msg)
  return repeat_msg_.Get(index);
}
inline ::Award* DBHello::mutable_repeat_msg(int index) {
  // @@protoc_insertion_point(field_mutable:DBHello.repeat_msg)
  return repeat_msg_.Mutable(index);
}
inline ::Award* DBHello::add_repeat_msg() {
  // @@protoc_insertion_point(field_add:DBHello.repeat_msg)
  return repeat_msg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Award >&
DBHello::repeat_msg() const {
  // @@protoc_insertion_point(field_list:DBHello.repeat_msg)
  return repeat_msg_;
}
inline ::google::protobuf::RepeatedPtrField< ::Award >*
DBHello::mutable_repeat_msg() {
  // @@protoc_insertion_point(field_mutable_list:DBHello.repeat_msg)
  return &repeat_msg_;
}

// optional .EnumDef_value ev = 10;
inline bool DBHello::has_ev() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DBHello::set_has_ev() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DBHello::clear_has_ev() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DBHello::clear_ev() {
  ev_ = 0;
  clear_has_ev();
}
inline ::EnumDef_value DBHello::ev() const {
  // @@protoc_insertion_point(field_get:DBHello.ev)
  return static_cast< ::EnumDef_value >(ev_);
}
inline void DBHello::set_ev(::EnumDef_value value) {
  assert(::EnumDef_value_IsValid(value));
  set_has_ev();
  ev_ = value;
  // @@protoc_insertion_point(field_set:DBHello.ev)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::EnumDef_value> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EnumDef_value>() {
  return ::EnumDef_value_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_test_2eproto__INCLUDED
