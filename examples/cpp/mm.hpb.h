#pragma once

//this file is auto generated by (hbpex)[https://github.com/jj4jj/hpbex.git] , don't edit this file !
//file generate datetime: Mon Dec  7 19:53:37 2015

#include <algorithm>
#include "comm.hpb.h"
#include "db.hpb.h"
#include "mm.pb.h"

namespace mm { 

using db::DBTest_ST;

struct PK_ST {
    int32_t		id;
    DBTest_ST		db;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        id = 0;
        db.construct();
    }
    void		convto(PK & convtomsg_) const {
        convtomsg_.set_id(id);
        db.convto(*convtomsg_.mutable_db());
    }
    void		convfrom(const PK & convfrommsg_) {
        id = convfrommsg_.id();
        db.convfrom(convfrommsg_.db());
    }
    int		compare(const PK_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (id < rhs_.id) ? -1 : ((id == rhs_.id) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const PK_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const PK_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct Hero_ST {
    int32_t		id;
    CommBase_ST		base;
    struct {size_t count; int32_t list[32];}		id_list;
    struct {size_t count; PK_ST list[MAX_PK_COUNT];}		pk_list;
    struct { char data[32]; }		str;
    float		f32;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        id = 0;
        base.construct();
        id_list.count = 0U;
        pk_list.count = 0U;
        str.data[0] = 0;
        f32 = 0;
    }
    void		convto(Hero & convtomsg_) const {
        convtomsg_.set_id(id);
        base.convto(*convtomsg_.mutable_base());
        assert(id_list.count <= 32);//assertion
        for ( size_t i = 0; i < id_list.count && i < (sizeof(id_list.list)/sizeof(id_list.list[0])); ++i){
            convtomsg_.add_id_list(id_list.list[i]);
        }
        assert(pk_list.count <= MAX_PK_COUNT);//assertion
        for ( size_t i = 0; i < pk_list.count && i < (sizeof(pk_list.list)/sizeof(pk_list.list[0])); ++i){
            pk_list.list[i].convto(*convtomsg_.add_pk_list());
        }
        convtomsg_.set_str(str.data);
        convtomsg_.set_f32(f32);
    }
    void		convfrom(const Hero & convfrommsg_) {
        id = convfrommsg_.id();
        base.convfrom(convfrommsg_.base());
        assert(convfrommsg_.id_list_size() <= 32);//assertion
        id_list.count = 0;
        for ( size_t i = 0; i < (size_t)convfrommsg_.id_list_size() && i < (sizeof(id_list.list)/sizeof(id_list.list[0])); ++i){
            id_list.list[i] = convfrommsg_.id_list(i);
            ++id_list.count;
        }
        assert(convfrommsg_.pk_list_size() <= MAX_PK_COUNT);//assertion
        pk_list.count = 0;
        for ( size_t i = 0; i < (size_t)convfrommsg_.pk_list_size() && i < (sizeof(pk_list.list)/sizeof(pk_list.list[0])); ++i){
            pk_list.list[i].convfrom(convfrommsg_.pk_list(i));
            ++pk_list.count;
        }
        strncpy(str.data, convfrommsg_.str().data(), 32-1);
        f32 = convfrommsg_.f32();
    }
    int		compare(const Hero_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (id < rhs_.id) ? -1 : ((id == rhs_.id) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = base.compare(rhs_.base);
        if (_cmp_ret != 0) { return _cmp_ret; }
        for (size_t i = 0; i < id_list.count && i < rhs_.id_list.count; ++i) {
            _cmp_ret = (id_list.list[i] < rhs_.id_list.list[i]) ? -1 : ((id_list.list[i] == rhs_.id_list.list[i]) ? 0 : 1);
            if (_cmp_ret != 0) { return _cmp_ret; }
        }
        _cmp_ret = (id_list.count < rhs_.id_list.count ) ? -1 : ((id_list.count == rhs_.id_list.count ) ? 0 : 1);
        for (size_t i = 0; i < pk_list.count && i < rhs_.pk_list.count; ++i) {
            _cmp_ret = pk_list.list[i].compare(rhs_.pk_list.list[i]);
            if (_cmp_ret != 0) { return _cmp_ret; }
        }
        _cmp_ret = (pk_list.count < rhs_.pk_list.count ) ? -1 : ((pk_list.count == rhs_.pk_list.count ) ? 0 : 1);
        _cmp_ret = strncmp(str.data, rhs_.str.data, 32);
        if (_cmp_ret != 0) { return _cmp_ret; }
        #warning "comparing variable is a float number , maybe not precise .";
        _cmp_ret = ((f32 + 10e-6) < rhs_.f32) ? -1 : (f32 > (rhs_.f32 + 10e-6) ? 1 : 0);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const Hero_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const Hero_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
    int		find_idx_id_list(const int32_t & entry_) {
        auto it = std::find(id_list.list, id_list.list + id_list.count, entry_);
        if ( it != id_list.list + id_list.count ) { return it - id_list.list; }
        return -1;
    }
    int		append_id_list(const int32_t & entry_, bool shift_ = false) {
        if ( id_list.count < 32 ) {
            id_list.list[id_list.count] = entry_;
            ++id_list.count;
        }
        else {
            if ( !shift_ ) { return -2; }
            memmove(id_list.list, id_list.list + 1, (32-1)*sizeof(id_list.list[0]));
            id_list.list[32 - 1] = entry_;
        }
        return 0;
    }
    int		insert_id_list(size_t idx_, const int32_t & entry_, bool shift_force_insert_ = false) {
        if ( idx_ >= 32 || idx_ > id_list.count ) { return -2; }
        if ( id_list.count < 32 ) {
            memmove(id_list.list + idx_ + 1, id_list.list + idx_, (id_list.count - idx_)*sizeof(id_list.list[0]));
            id_list.list[idx_] = entry_;
            ++id_list.count;
        }
        else {
            if ( !shift_force_insert_ ) { return -3; }
            memmove(id_list.list + idx_ + 1, id_list.list + idx_, (32 - 1 - idx_)*sizeof(id_list.list[0]));
            id_list.list[idx_] = entry_;
        }
        return 0;
    }
    int		remove_id_list(size_t idx_, bool shift_not_swap_ = true) {
        if ( idx_ >= id_list.count ) { return -1; }
        if ( shift_not_swap_ ) {
            memmove(id_list.list + idx_, id_list.list + idx_ + 1, (id_list.count - idx_ - 1)*sizeof(id_list.list[0]));
        }
        else { id_list.list[idx_] = id_list.list[id_list.count - 1]; }
        --id_list.count;
        return 0;
    }
    int		lower_bound_id_list(const int32_t & entry_) {
        auto it = std::lower_bound(id_list.list, id_list.list + id_list.count, entry_);
        if ( it != id_list.list + id_list.count ) { return it - id_list.list; }
        return -1;
    }
    int		upper_bound_id_list(const int32_t & entry_) {
        auto it = std::upper_bound(id_list.list, id_list.list + id_list.count, entry_);
        if ( it != id_list.list + id_list.count ) { return it - id_list.list; }
        return -1;
    }
    int		binsert_id_list(const int32_t & entry_, bool shift_force_insert_ = false) {
        int idx_ = upper_bound_id_list(entry_);
        if ( idx_ < 0 ) { return append_id_list(entry_, shift_force_insert_); }
        return insert_id_list(idx_, entry_, shift_force_insert_);
    }
    int		find_idx_pk_list(const PK_ST & entry_) {
        auto it = std::find(pk_list.list, pk_list.list + pk_list.count, entry_);
        if ( it != pk_list.list + pk_list.count ) { return it - pk_list.list; }
        return -1;
    }
    int		append_pk_list(const PK_ST & entry_, bool shift_ = false) {
        if ( pk_list.count < MAX_PK_COUNT ) {
            pk_list.list[pk_list.count] = entry_;
            ++pk_list.count;
        }
        else {
            if ( !shift_ ) { return -2; }
            memmove(pk_list.list, pk_list.list + 1, (MAX_PK_COUNT-1)*sizeof(pk_list.list[0]));
            pk_list.list[MAX_PK_COUNT - 1] = entry_;
        }
        return 0;
    }
    int		insert_pk_list(size_t idx_, const PK_ST & entry_, bool shift_force_insert_ = false) {
        if ( idx_ >= MAX_PK_COUNT || idx_ > pk_list.count ) { return -2; }
        if ( pk_list.count < MAX_PK_COUNT ) {
            memmove(pk_list.list + idx_ + 1, pk_list.list + idx_, (pk_list.count - idx_)*sizeof(pk_list.list[0]));
            pk_list.list[idx_] = entry_;
            ++pk_list.count;
        }
        else {
            if ( !shift_force_insert_ ) { return -3; }
            memmove(pk_list.list + idx_ + 1, pk_list.list + idx_, (MAX_PK_COUNT - 1 - idx_)*sizeof(pk_list.list[0]));
            pk_list.list[idx_] = entry_;
        }
        return 0;
    }
    int		remove_pk_list(size_t idx_, bool shift_not_swap_ = true) {
        if ( idx_ >= pk_list.count ) { return -1; }
        if ( shift_not_swap_ ) {
            memmove(pk_list.list + idx_, pk_list.list + idx_ + 1, (pk_list.count - idx_ - 1)*sizeof(pk_list.list[0]));
        }
        else { pk_list.list[idx_] = pk_list.list[pk_list.count - 1]; }
        --pk_list.count;
        return 0;
    }
    int		lower_bound_pk_list(const PK_ST & entry_) {
        auto it = std::lower_bound(pk_list.list, pk_list.list + pk_list.count, entry_);
        if ( it != pk_list.list + pk_list.count ) { return it - pk_list.list; }
        return -1;
    }
    int		upper_bound_pk_list(const PK_ST & entry_) {
        auto it = std::upper_bound(pk_list.list, pk_list.list + pk_list.count, entry_);
        if ( it != pk_list.list + pk_list.count ) { return it - pk_list.list; }
        return -1;
    }
    int		binsert_pk_list(const PK_ST & entry_, bool shift_force_insert_ = false) {
        int idx_ = upper_bound_pk_list(entry_);
        if ( idx_ < 0 ) { return append_pk_list(entry_, shift_force_insert_); }
        return insert_pk_list(idx_, entry_, shift_force_insert_);
    }
};

} // end of namespace: mm

