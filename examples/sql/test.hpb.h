#pragma once

//this file is auto generated by (hbpex)[https://github.com/jj4jj/hpbex.git] , don't edit this file !
//file generate datetime: Mon Dec  7 20:07:41 2015

#include <algorithm>
#include "test.pb.h"



struct HelloA_ST {
    int32_t		f1;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        f1 = 0;
    }
    void		convto(HelloA & convtomsg_) const {
        convtomsg_.set_f1(f1);
    }
    void		convfrom(const HelloA & convfrommsg_) {
        f1 = convfrommsg_.f1();
    }
    int		compare(const HelloA_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (f1 < rhs_.f1) ? -1 : ((f1 == rhs_.f1) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const HelloA_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const HelloA_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct HelloB_ST {
    int32_t		f1;
    HelloA_ST		a;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        f1 = 0;
        a.construct();
    }
    void		convto(HelloB & convtomsg_) const {
        convtomsg_.set_f1(f1);
        a.convto(*convtomsg_.mutable_a());
    }
    void		convfrom(const HelloB & convfrommsg_) {
        f1 = convfrommsg_.f1();
        a.convfrom(convfrommsg_.a());
    }
    int		compare(const HelloB_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (f1 < rhs_.f1) ? -1 : ((f1 == rhs_.f1) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = a.compare(rhs_.a);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const HelloB_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const HelloB_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct HelloC_ST {
    int32_t		f1;
    HelloB_ST		b;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        f1 = 0;
        b.construct();
    }
    void		convto(HelloC & convtomsg_) const {
        convtomsg_.set_f1(f1);
        b.convto(*convtomsg_.mutable_b());
    }
    void		convfrom(const HelloC & convfrommsg_) {
        f1 = convfrommsg_.f1();
        b.convfrom(convfrommsg_.b());
    }
    int		compare(const HelloC_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (f1 < rhs_.f1) ? -1 : ((f1 == rhs_.f1) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = b.compare(rhs_.b);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const HelloC_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const HelloC_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct HelloD_ST {
    int32_t		f1;
    HelloB_ST		b;
    HelloC_ST		c;
    struct {size_t count; struct { size_t length; uint8_t data[20]; } list[5];}		d;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        f1 = 0;
        b.construct();
        c.construct();
        d.count = 0U;
    }
    void		convto(HelloD & convtomsg_) const {
        convtomsg_.set_f1(f1);
        b.convto(*convtomsg_.mutable_b());
        c.convto(*convtomsg_.mutable_c());
        assert(d.count <= 5);//assertion
        for ( size_t i = 0; i < d.count && i < (sizeof(d.list)/sizeof(d.list[0])); ++i){
            convtomsg_.add_d(d.list[i].data,d.list[i].length);
        }
    }
    void		convfrom(const HelloD & convfrommsg_) {
        f1 = convfrommsg_.f1();
        b.convfrom(convfrommsg_.b());
        c.convfrom(convfrommsg_.c());
        assert(convfrommsg_.d_size() <= 5);//assertion
        d.count = 0;
        for ( size_t i = 0; i < (size_t)convfrommsg_.d_size() && i < (sizeof(d.list)/sizeof(d.list[0])); ++i){
            memcpy(d.list[i].data, convfrommsg_.d(i).data(), std::min((size_t)20, (size_t)convfrommsg_.d(i).length()));
            ++d.count;
        }
    }
    int		compare(const HelloD_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (f1 < rhs_.f1) ? -1 : ((f1 == rhs_.f1) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const HelloD_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const HelloD_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct Award_ST {
    uint32_t		id;
    uint32_t		num;
    uint32_t		param;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        id = 0;
        num = 0;
        param = 0;
    }
    void		convto(Award & convtomsg_) const {
        convtomsg_.set_id(id);
        convtomsg_.set_num(num);
        convtomsg_.set_param(param);
    }
    void		convfrom(const Award & convfrommsg_) {
        id = convfrommsg_.id();
        num = convfrommsg_.num();
        param = convfrommsg_.param();
    }
    int		compare(const Award_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (id < rhs_.id) ? -1 : ((id == rhs_.id) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (num < rhs_.num) ? -1 : ((num == rhs_.num) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (param < rhs_.param) ? -1 : ((param == rhs_.param) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const Award_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const Award_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct Hello_ST {
    int32_t		id;
    struct {size_t count; struct { char data[32]; } list[32];}		myworld;
    HelloD_ST		d;
    EnumDef_value		ev;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        id = 0;
        myworld.count = 0U;
        d.construct();
        ev = EN_DEFAULT_VALUE;//should be 0
    }
    void		convto(Hello & convtomsg_) const {
        convtomsg_.set_id(id);
        assert(myworld.count <= 32);//assertion
        for ( size_t i = 0; i < myworld.count && i < (sizeof(myworld.list)/sizeof(myworld.list[0])); ++i){
            convtomsg_.add_myworld(myworld.list[i].data);
        }
        d.convto(*convtomsg_.mutable_d());
        convtomsg_.set_ev(ev);
    }
    void		convfrom(const Hello & convfrommsg_) {
        id = convfrommsg_.id();
        assert(convfrommsg_.myworld_size() <= 32);//assertion
        myworld.count = 0;
        for ( size_t i = 0; i < (size_t)convfrommsg_.myworld_size() && i < (sizeof(myworld.list)/sizeof(myworld.list[0])); ++i){
            strncpy(myworld.list[i].data, convfrommsg_.myworld(i).data(), 32-1);
            ++myworld.count;
        }
        d.convfrom(convfrommsg_.d());
        ev = convfrommsg_.ev();
    }
    int		compare(const Hello_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (id < rhs_.id) ? -1 : ((id == rhs_.id) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const Hello_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const Hello_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
    int		find_idx_myworld(const std::string & entry_) {
        auto it = std::find_if(myworld.list, myworld.list + myworld.count, 
            [&entry_](decltype(myworld.list[0]) & st) ->bool { return entry_ == st.data; }); 
        if ( it != myworld.list + myworld.count ) { return it - myworld.list; }
        return -1;
    }
    int		append_myworld(const std::string & entry_, bool shift_ = true) {
        if ( entry_.length() >= 32 ) { return -1; }
        if ( myworld.count < 32 ) {
            strncpy(myworld.list[myworld.count].data, entry_.c_str(), 32-1);
            ++myworld.count;
        }
        else {
            if ( !shift_ ) { return -2; }
            memmove(myworld.list, myworld.list + 1, (32-1)*sizeof(myworld.list[0]));
            strncpy(myworld.list[32 - 1].data, entry_.c_str(), 32-1);
        }
        return 0;
    }
    int		insert_myworld(size_t idx_, const std::string & entry_, bool shift_force_insert_ = true) {
        if ( entry_.length() >= 32 ) { return -1; }
        if ( idx_ > myworld.count ) { return -2; }
        if ( myworld.count < 32 ) {
            memmove(myworld.list + idx_ + 1, myworld.list + idx_, (myworld.count - idx_)*sizeof(myworld.list[0]));
            strncpy(myworld.list[idx_].data, entry_.c_str(), 32-1);
            ++myworld.count;
        }
        else {
            if ( !shift_force_insert_ ) { return -3; }
            memmove(myworld.list + idx_ + 1, myworld.list + idx_, (32 - 1 - idx_)*sizeof(myworld.list[0]));
            strncpy(myworld.list[idx_].data, entry_.c_str(), 32-1);
        }
        return 0;
    }
    int		remove_myworld(size_t idx_, bool shift_not_swap_ = true) {
        if ( idx_ >= myworld.count ) { return -1; }
        if ( shift_not_swap_ ) {
            memmove(myworld.list + idx_, myworld.list + idx_ + 1, (myworld.count - idx_ - 1)*sizeof(myworld.list[0]));
        }
        else { myworld.list[idx_] = myworld.list[myworld.count - 1]; }
        --myworld.count;
        return 0;
    }
    int		lower_bound_myworld(const std::string & entry_) {
        auto it = std::lower_bound(myworld.list, myworld.list + myworld.count, entry_,
            [](decltype(myworld.list[0]) & t2, const std::string & t1) ->bool { return t1 < t2.data; }); 
        if ( it != myworld.list + myworld.count ) { return it - myworld.list; }
        return -1;
    }
    int		upper_bound_myworld(const std::string & entry_) {
        auto it = std::upper_bound(myworld.list, myworld.list + myworld.count, entry_,
            [](const std::string & t1,decltype(myworld.list[0]) & t2) ->bool { return t1 < t2.data; }); 
        if ( it != myworld.list + myworld.count ) { return it - myworld.list; }
        return -1;
    }
    int		binsert_myworld(const std::string & entry_, bool shift_force_insert_ = false) {
        int idx_ = upper_bound_myworld(entry_);
        if ( idx_ < 0 ) { return append_myworld(entry_, shift_force_insert_); }
        return insert_myworld(idx_, entry_, shift_force_insert_);
    }
};
struct DBHello_ST {
    uint64_t		pk1;
    struct { char data[MAX_NAME_LENGTH]; }		pk2;
    uint32_t		f1;
    struct { char data[32]; }		f2;
    Hello_ST		hello;
    bool		b4;
    struct { size_t length; uint8_t data[MAX_BUFF_NUM]; }		bytesmsg;
    struct {size_t count; uint32_t list[32];}		repeat_test;
    struct {size_t count; Award_ST list[5];}		repeat_msg;
    EnumDef_value		ev;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        pk1 = 0;
        pk2.data[0] = 0;
        f1 = 0;
        f2.data[0] = 0;
        hello.construct();
        b4 = 0;
        bytesmsg.length = 0U;
        repeat_test.count = 0U;
        repeat_msg.count = 0U;
        ev = EN_DEFAULT_VALUE;//should be 0
    }
    void		convto(DBHello & convtomsg_) const {
        convtomsg_.set_pk1(pk1);
        convtomsg_.set_pk2(pk2.data);
        convtomsg_.set_f1(f1);
        convtomsg_.set_f2(f2.data);
        hello.convto(*convtomsg_.mutable_hello());
        convtomsg_.set_b4(b4);
        convtomsg_.set_bytesmsg(bytesmsg.data,bytesmsg.length);
        assert(repeat_test.count <= 32);//assertion
        for ( size_t i = 0; i < repeat_test.count && i < (sizeof(repeat_test.list)/sizeof(repeat_test.list[0])); ++i){
            convtomsg_.add_repeat_test(repeat_test.list[i]);
        }
        assert(repeat_msg.count <= 5);//assertion
        for ( size_t i = 0; i < repeat_msg.count && i < (sizeof(repeat_msg.list)/sizeof(repeat_msg.list[0])); ++i){
            repeat_msg.list[i].convto(*convtomsg_.add_repeat_msg());
        }
        convtomsg_.set_ev(ev);
    }
    void		convfrom(const DBHello & convfrommsg_) {
        pk1 = convfrommsg_.pk1();
        strncpy(pk2.data, convfrommsg_.pk2().data(), MAX_NAME_LENGTH-1);
        f1 = convfrommsg_.f1();
        strncpy(f2.data, convfrommsg_.f2().data(), 32-1);
        hello.convfrom(convfrommsg_.hello());
        b4 = convfrommsg_.b4();
        memcpy(bytesmsg.data, convfrommsg_.bytesmsg().data(), std::min((size_t)MAX_BUFF_NUM, (size_t)convfrommsg_.bytesmsg().length()));
        assert(convfrommsg_.repeat_test_size() <= 32);//assertion
        repeat_test.count = 0;
        for ( size_t i = 0; i < (size_t)convfrommsg_.repeat_test_size() && i < (sizeof(repeat_test.list)/sizeof(repeat_test.list[0])); ++i){
            repeat_test.list[i] = convfrommsg_.repeat_test(i);
            ++repeat_test.count;
        }
        assert(convfrommsg_.repeat_msg_size() <= 5);//assertion
        repeat_msg.count = 0;
        for ( size_t i = 0; i < (size_t)convfrommsg_.repeat_msg_size() && i < (sizeof(repeat_msg.list)/sizeof(repeat_msg.list[0])); ++i){
            repeat_msg.list[i].convfrom(convfrommsg_.repeat_msg(i));
            ++repeat_msg.count;
        }
        ev = convfrommsg_.ev();
    }
    int		compare(const DBHello_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = (pk1 < rhs_.pk1) ? -1 : ((pk1 == rhs_.pk1) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(pk2.data, rhs_.pk2.data, MAX_NAME_LENGTH);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const DBHello_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const DBHello_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
    int		find_idx_repeat_test(const uint32_t & entry_) {
        auto it = std::find(repeat_test.list, repeat_test.list + repeat_test.count, entry_);
        if ( it != repeat_test.list + repeat_test.count ) { return it - repeat_test.list; }
        return -1;
    }
    int		append_repeat_test(const uint32_t & entry_, bool shift_ = false) {
        if ( repeat_test.count < 32 ) {
            repeat_test.list[repeat_test.count] = entry_;
            ++repeat_test.count;
        }
        else {
            if ( !shift_ ) { return -2; }
            memmove(repeat_test.list, repeat_test.list + 1, (32-1)*sizeof(repeat_test.list[0]));
            repeat_test.list[32 - 1] = entry_;
        }
        return 0;
    }
    int		insert_repeat_test(size_t idx_, const uint32_t & entry_, bool shift_force_insert_ = false) {
        if ( idx_ >= 32 || idx_ > repeat_test.count ) { return -2; }
        if ( repeat_test.count < 32 ) {
            memmove(repeat_test.list + idx_ + 1, repeat_test.list + idx_, (repeat_test.count - idx_)*sizeof(repeat_test.list[0]));
            repeat_test.list[idx_] = entry_;
            ++repeat_test.count;
        }
        else {
            if ( !shift_force_insert_ ) { return -3; }
            memmove(repeat_test.list + idx_ + 1, repeat_test.list + idx_, (32 - 1 - idx_)*sizeof(repeat_test.list[0]));
            repeat_test.list[idx_] = entry_;
        }
        return 0;
    }
    int		remove_repeat_test(size_t idx_, bool shift_not_swap_ = true) {
        if ( idx_ >= repeat_test.count ) { return -1; }
        if ( shift_not_swap_ ) {
            memmove(repeat_test.list + idx_, repeat_test.list + idx_ + 1, (repeat_test.count - idx_ - 1)*sizeof(repeat_test.list[0]));
        }
        else { repeat_test.list[idx_] = repeat_test.list[repeat_test.count - 1]; }
        --repeat_test.count;
        return 0;
    }
    int		lower_bound_repeat_test(const uint32_t & entry_) {
        auto it = std::lower_bound(repeat_test.list, repeat_test.list + repeat_test.count, entry_);
        if ( it != repeat_test.list + repeat_test.count ) { return it - repeat_test.list; }
        return -1;
    }
    int		upper_bound_repeat_test(const uint32_t & entry_) {
        auto it = std::upper_bound(repeat_test.list, repeat_test.list + repeat_test.count, entry_);
        if ( it != repeat_test.list + repeat_test.count ) { return it - repeat_test.list; }
        return -1;
    }
    int		binsert_repeat_test(const uint32_t & entry_, bool shift_force_insert_ = false) {
        int idx_ = upper_bound_repeat_test(entry_);
        if ( idx_ < 0 ) { return append_repeat_test(entry_, shift_force_insert_); }
        return insert_repeat_test(idx_, entry_, shift_force_insert_);
    }
    int		find_idx_repeat_msg(const Award_ST & entry_) {
        auto it = std::find(repeat_msg.list, repeat_msg.list + repeat_msg.count, entry_);
        if ( it != repeat_msg.list + repeat_msg.count ) { return it - repeat_msg.list; }
        return -1;
    }
    int		append_repeat_msg(const Award_ST & entry_, bool shift_ = false) {
        if ( repeat_msg.count < 5 ) {
            repeat_msg.list[repeat_msg.count] = entry_;
            ++repeat_msg.count;
        }
        else {
            if ( !shift_ ) { return -2; }
            memmove(repeat_msg.list, repeat_msg.list + 1, (5-1)*sizeof(repeat_msg.list[0]));
            repeat_msg.list[5 - 1] = entry_;
        }
        return 0;
    }
    int		insert_repeat_msg(size_t idx_, const Award_ST & entry_, bool shift_force_insert_ = false) {
        if ( idx_ >= 5 || idx_ > repeat_msg.count ) { return -2; }
        if ( repeat_msg.count < 5 ) {
            memmove(repeat_msg.list + idx_ + 1, repeat_msg.list + idx_, (repeat_msg.count - idx_)*sizeof(repeat_msg.list[0]));
            repeat_msg.list[idx_] = entry_;
            ++repeat_msg.count;
        }
        else {
            if ( !shift_force_insert_ ) { return -3; }
            memmove(repeat_msg.list + idx_ + 1, repeat_msg.list + idx_, (5 - 1 - idx_)*sizeof(repeat_msg.list[0]));
            repeat_msg.list[idx_] = entry_;
        }
        return 0;
    }
    int		remove_repeat_msg(size_t idx_, bool shift_not_swap_ = true) {
        if ( idx_ >= repeat_msg.count ) { return -1; }
        if ( shift_not_swap_ ) {
            memmove(repeat_msg.list + idx_, repeat_msg.list + idx_ + 1, (repeat_msg.count - idx_ - 1)*sizeof(repeat_msg.list[0]));
        }
        else { repeat_msg.list[idx_] = repeat_msg.list[repeat_msg.count - 1]; }
        --repeat_msg.count;
        return 0;
    }
    int		lower_bound_repeat_msg(const Award_ST & entry_) {
        auto it = std::lower_bound(repeat_msg.list, repeat_msg.list + repeat_msg.count, entry_);
        if ( it != repeat_msg.list + repeat_msg.count ) { return it - repeat_msg.list; }
        return -1;
    }
    int		upper_bound_repeat_msg(const Award_ST & entry_) {
        auto it = std::upper_bound(repeat_msg.list, repeat_msg.list + repeat_msg.count, entry_);
        if ( it != repeat_msg.list + repeat_msg.count ) { return it - repeat_msg.list; }
        return -1;
    }
    int		binsert_repeat_msg(const Award_ST & entry_, bool shift_force_insert_ = false) {
        int idx_ = upper_bound_repeat_msg(entry_);
        if ( idx_ < 0 ) { return append_repeat_msg(entry_, shift_force_insert_); }
        return insert_repeat_msg(idx_, entry_, shift_force_insert_);
    }
};


